{"name":"sw-hec-autoconf","data":{"formList":[{"fieldId":"leafNrInput","fieldLabel":"Leaf Number","type":"Text box","value":"","depends":"","validation":{"mandatory":false},"dataValidation":"","helpText":"","configletBuilderId":"configletBuilderMapper_8062_1533453647834190","orderId":0,"key":"field_1_1556002500295","dataValidationErrorExist":false,"previewValue":""},{"fieldId":"leafType","fieldLabel":"Leaf Type:","type":"Radio button","value":"hvx,hana,hvv","depends":"","validation":{"mandatory":true},"dataValidation":"","helpText":"","configletBuilderId":"configletBuilderMapper_8062_1533453647834190","orderId":1,"key":"field_2_1556002566072","dataValidationErrorExist":false,"previewValue":""},{"fieldId":"snmpContact","fieldLabel":"SNMP Contact (format: 'Equi:console-server:port')","type":"Text box","value":"","depends":"","validation":{"mandatory":false},"dataValidation":"","helpText":"","configletBuilderId":"configletBuilderMapper_8062_1533453647834190","orderId":2,"key":"field_3_1556002650464","dataValidationErrorExist":false,"previewValue":""},{"fieldId":"snmpLocation","fieldLabel":"SNMP Location","type":"Text box","value":"","depends":"","validation":{"mandatory":false},"dataValidation":"","helpText":"","configletBuilderId":"configletBuilderMapper_8062_1533453647834190","orderId":3,"key":"field_4_1556002680982","dataValidationErrorExist":false,"previewValue":""}],"type":"BUILDER_WITHOUT_DRAFT","main_script":{"data":"import jsonrpclib\nfrom cvplibrary import CVPGlobalVariables, GlobalVariableNames\nfrom cvplibrary import RestClient\nfrom cvplibrary import Form\nimport sys\nimport json\nimport cvp\nimport cvpServices\nimport errorCodes\nimport socket\nimport time\nimport ssl\nfrom string import Template\n\n\n# ================================================================================\n# Providing an -unverififed- default context. We're only using it in ZTP, so no\n# security concerns to be raised.\n# ================================================================================\n\nif ((sys.version_info.major == 3) or\n    (sys.version_info.major == 2 and sys.version_info.minor == 7 and sys.version_info.micro >= 5)):\n    ssl._create_default_https_context = ssl._create_unverified_context\n# ================================================================================\n\n# *********************  Variable file which need to be present as configlet ************************************************\nINI_FILE = 'autoconf.ini'  # All variables are stored in this ini file\n\n\ndef main():\n  \n  # ================================================================================\n  # The autoconf script automatically creates configlets:\n  #   sw-hecXX-hana-7160-32CQ =(static)= model-based template\n  #   mlag-[a|b] =(static)= will be assigned based on 'a' or 'b' position in MLAG\n  #   sw-hecXX-hana-01 =(individual/pair)= auto-generated based on position\n  #   sw-hecXX-hana-01[a|b] =(individual)= auto-generated based on position\n  # ================================================================================\n  \n  # Get values from the interactive form:\n  # - the number used in 'sw-hecXX-hana-XXa'\n  leafNrInputS = str(Form.getFieldById('leafNrInput').getValue())\n  # - the type used in 'sw-hecXX-XXX-01a'\n  leafType     = str(Form.getFieldById('leafType').getValue())\n  # - SNMP contact, normally in format: 'Equi:console-server:port'\n  snmpContact  = str(Form.getFieldById('snmpContact').getValue())\n  # - SNMP location, normally in format: 'Country-DC-Cage-Row-Rack-Position'\n  snmpLocation = str(Form.getFieldById('snmpLocation').getValue())\n  \n  # The replacement dict is used to provide variables to the templates\n  Replacements = {}\n\n  try:\n    leafNrInput = int (leafNrInputS)\n  except:\n    leafNrInput = 0\n    \n    \n  ztp = CVPGlobalVariables.getValue(GlobalVariableNames.ZTP_STATE)\n  ip  = CVPGlobalVariables.getValue(GlobalVariableNames.CVP_IP)\n  mac = CVPGlobalVariables.getValue(GlobalVariableNames.CVP_MAC)\n  \n  cvpuser   = CVPGlobalVariables.getValue(GlobalVariableNames.CVP_USERNAME)\n  cvppasswd = CVPGlobalVariables.getValue(GlobalVariableNames.CVP_PASSWORD)\n  user      = cvpuser    # Device access credentials\n  passwd    = cvppasswd  # usually equal to CVP access credentials, besides of ZTP mode\n  \n  if ztp == 'true':\n      user   = CVPGlobalVariables.getValue(GlobalVariableNames.ZTP_USERNAME)\n      passwd = CVPGlobalVariables.getValue(GlobalVariableNames.ZTP_PASSWORD)\n\n\n  # =======================================================\n  # Start the CVP session\n  # =======================================================\n  \n  server = cvp.Cvp('localhost')\n  try:\n    server.authenticate(cvpuser, cvppasswd)\n  except Exception as err:\n    print '! ERROR: Unable to authenticate to the CVP server as user: %s (%s)' % (cvpuser, err)\n    # raise cvpServices.CvpError (errorCodes.INVALID_ARGUMENT, 'Something went wrong')\n    return\n  \n\n  # Read ini file and store as global variables\n  try:\n    ini_file = server.cvpService.getConfigletByName(INI_FILE)\n    ini_text = ini_file['config']\n    \n    for line in ini_text.splitlines(True):\n      if '=' in line:\n        globals()[line.split('=')[0].lstrip().rstrip()] = json.loads(str(line.split('=')[1].lstrip().rstrip()))\n        \n  except Exception as err:\n    print '! ERROR: Required ini file %s does not exist or format is not correct! (%s)' % (INI_FILE, err)\n    return\n\n  # Provides dev.ipAddress, dev.fqdn, dev.macAddress, dev.containerName,\n  # dev.status, dev.model, dev.sn\n  try:\n    dev = server.getDevice (mac)\n    leafModel   = dev.model.lstrip('DCS-')  # Remove 'DCS-' at the beginning\n#    leafModel,_ = leafModel.rsplit ('-', 1) # Remove '-F'/'-R' at the end\n  except Exception as err:\n    print '! ERROR: Something went wrong during switch model identification (%s)' % (err)\n    return\n\n\n  # =======================================================\n  # Interacting with the switch\n  # =======================================================\n  \n  url    = 'https://%s:%s@%s/command-api' % (user, passwd, ip)\n  switch = jsonrpclib.Server(url)\n\n  transceivers = set()\n  try:  \n    # Get the transceiver used in the uplinks:\n    for all_iface in IF_SETUP[leafModel]:\n      for iface in all_iface['if'].split(','):\n        transceivers.add(switch.runCmds (1, ['enable', 'show interfaces Ethernet%s status' % iface])[1]['interfaceStatuses']['Ethernet%s' % iface]['interfaceType'])\n  except Exception as err:\n    print '! ERROR: Not able to contact device to read the transceiver type the uplinks: %s (%s)' % (ip, err)\n    return\n    \n    \n  # Verify that all transceivers are of the same type and if so get the speed to set statically\n  speed = ''\n  if len(transceivers) != 1:\n    print '! ERROR: There are different transceiver types used for the uplinks: %s' % (transceivers)\n    return\n  else:\n    transceiver = transceivers.pop()\n    if '10G' in transceiver:\n      speed = '10000full'\n    elif '40G' in transceiver:\n      speed = '40gfull'\n    elif '100G' in transceiver:\n      speed = '100gfull'\n    elif 'EbraTestPhyPort' in transceiver:\n      speed = '1000full'  \n  \n  \n  try:  \n    # Pre-condition the uplinks:\n    for iface in IF_SETUP[leafModel]:\n      _ = switch.runCmds(1, ['enable', 'configure', 'interface Ethernet%s' % iface['if'], 'speed forced %s' % speed])\n  except Exception as err:\n    print '! ERROR: Not able to contact device to precondition the uplinks: %s (%s)' % (ip, err)\n    return\n    \n  \n  # Wait for LLDP neighbors to update (10s):\n  time.sleep (10)\n\n\n  # Get the LLDP neighbor list:\n  try:\n    lldpNeighbors = switch.runCmds (1, ['enable', 'show lldp neighbors'])[1]['lldpNeighbors']\n  except Exception as err:\n    print '! ERROR: Not able to contact device to discover the neighbors: %s (%s)' % (ip, err)\n    return\n  \n  spineMod     = ''\n  spinePort    = ''\n  oldSpine     = ''\n  oldSpineMod  = ''\n  oldSpinePort = ''\n  \n  spines = {}\n  \n  try:  \n    for neighbor in lldpNeighbors:\n        nghb = str(neighbor['neighborDevice'].split('.')[0])\n        if (nghb in SPINES):\n            nghbPort = neighbor['neighborPort'][8:] # Ignoring leading 'Ethernet'\n            if ('/' in nghbPort):\n                spineMod, spinePort, _ = nghbPort.split('/')\n            else:\n                spineMod  = '3' # Equiv to the first LC in a chassis\n                spinePort = nghbPort\n    \n            leafNr  = ((int(spineMod)-3) * 36 + int(spinePort) -1) / 2 + 1\n            leafLtr = 'ba'[int(spinePort) % 2]\n            leafIP  = ((int(spineMod)-3) * 36 + int(spinePort) -1) * 2 + 1\n            \n            # Store the information for this spine in a dictionary for all spine information needed\n            spines[nghb] = {}\n            spines[nghb]['interface'] = neighbor['port']\n            spines[nghb]['neighbor_port'] = neighbor['neighborPort']\n            spines[nghb]['ip_address'] = '10.%s.%s.%s' % (nghb[-2:], leafIP / 256, leafIP % 256)\n    \n            if (oldSpine != ''):\n                if (oldSpineMod != spineMod):\n                    print ('! ERROR: Cabling mismatch, %s:%s%s vs %s:%s%s' % (spine, spineMod, spinePort, oldSpine, oldSpineMod, oldSpinePort))\n                if (oldSpinePort != spinePort):\n                    print ('! ERROR: Cabling mismatch, %s:%s%s vs %s:%s%s' % (spine, spineMod, spinePort, oldSpine, oldSpineMod, oldSpinePort))\n    \n            oldSpine     = nghb\n            oldSpineMod  = spineMod\n            oldSpinePort = spinePort\n  except Exception as err:\n    print '! ERROR: Position calculation went wrong (%s)' % (err)\n    return\n\n  # Verify if all four spines were seen as neighbor\n  spine_keys = spines.keys()\n  if len(spine_keys) != 4:\n    print '! ERROR: Switch is not connected to all Spines. Currently it is connected to %s' % (str(spine_keys))\n    return\n  else:\n    print '! Switch is connected to all Spines %s' % (str(spine_keys))\n    \n\n  if (leafNrInput == 0):\n      leafNrInput = leafNr\n  \n  hostName = 'sw-%s-%s-%02d%s' % (LOCATION, leafType, leafNrInput, leafLtr)\n  mlagName = 'sw-%s-%s-%02d'   % (LOCATION, leafType, leafNrInput)\n  \n \n  # =======================================================\n  # Verify that the individual configlet does not exist already (config)\n  # =======================================================\n  configlet_name = '%s' % hostName\n  \n  try:\n    cfg = server.cvpService.getConfigletByName (configlet_name)\n    print ('! ERROR: Configlet %s already exists. Delete/rename to be able to re-create!' % configlet_name)\n    return\n  except cvp.cvpServices.CvpError as err:\n    if (err.errorCode == errorCodes.ENTITY_DOES_NOT_EXIST):\n      print '! Configlet %s does not exist and will be created.' % configlet_name\n    else:\n      print '! ERROR: Communication issues with configlet %s! (%s)' % (configlet_name, err)\n      return\n\n  \n  # ========== Lo1 config ==========\n  oct4 = 100 if leafLtr == 'b' else 0\n  lo1 = '10.%s.%s.%s' % (100 + leafNr/100, POD, leafNr%100 + oct4)\n\n  \n  # ========== Ma1 config ==========\n  ma_vrf = MA_VRF\n  if (ma_vrf == ''):\n    ma_vrf = 'default'\n\n  # DNS lookup for hostname to discover Ma1 IP\n  try:\n    MA_IP = socket.gethostbyname (hostName + '.' + MA_DOMAIN)\n  except Exception as err:\n    print '! ERROR: Not able to resolve Ma1-hostname: %s (%s)' % (hostName + '.' + MA_DOMAIN, err)\n    return\n\n  \n  # ========== Lo900 config ==========\n\n  # DNS lookup for hostname to discover Lo900 IP\n  try:\n    lo900 = socket.gethostbyname (hostName + '.' + LO900_DOMAIN)\n  except Exception as err:\n    print '! ERROR: Not able to resolve Lo900-hostname: %s (%s)' % (hostName + '.' + LO900_DOMAIN, err)\n    return\n\n\n  # ========== Lo2 config ==========\n  lo2 = '10.%s.%s.%s' % (200 + leafNr/100, POD, leafNr%100)\n  \n  # ========== BGP AS ==========\n  BGP_AS = ('%s.%s' % (LEAF_AS1, LEAF_AS2+leafNr))\n  MLAG_NEIGHBOR_IP = IBGP_PEER[leafLtr]  \n    \n    \n\n\n  # =======================================================\n  # Preparing the dict for the template replacement\n  # =======================================================\n  \n  # Set the values for the Spines in the replacement dict \n  spine_counter = 1\n  sorted_spines_keys = sorted(spines.keys())\n  for key in sorted_spines_keys:\n    if spine_counter == 1:\n       Replacements['SPINE1_INTERFACE'] = spines[key]['interface']\n       Replacements['SPINE1_NAME'] = key\n       Replacements['SPINE1_PORT'] = spines[key]['neighbor_port']\n       Replacements['SPINE1_IP'] = spines[key]['ip_address']\n       Replacements['SPINE1_NEIGHBOR_IP'] = '10.%s.%s.%s' % (key[-2:], leafIP / 256, leafIP % 256 - 1)\n       spine_counter = spine_counter + 1\n    elif spine_counter == 2:\n       Replacements['SPINE2_INTERFACE'] = spines[key]['interface']\n       Replacements['SPINE2_NAME'] = key\n       Replacements['SPINE2_PORT'] = spines[key]['neighbor_port']\n       Replacements['SPINE2_IP'] = spines[key]['ip_address']\n       Replacements['SPINE2_NEIGHBOR_IP'] = '10.%s.%s.%s' % (key[-2:], leafIP / 256, leafIP % 256 - 1)\n       spine_counter = spine_counter + 1\n    elif spine_counter == 3:\n       Replacements['SPINE3_INTERFACE'] = spines[key]['interface']\n       Replacements['SPINE3_NAME'] = key\n       Replacements['SPINE3_PORT'] = spines[key]['neighbor_port']\n       Replacements['SPINE3_IP'] = spines[key]['ip_address']\n       Replacements['SPINE3_NEIGHBOR_IP'] = '10.%s.%s.%s' % (key[-2:], leafIP / 256, leafIP % 256 - 1)\n       spine_counter = spine_counter + 1\n    elif spine_counter == 4:\n       Replacements['SPINE4_INTERFACE'] = spines[key]['interface']\n       Replacements['SPINE4_NAME'] = key\n       Replacements['SPINE4_PORT'] = spines[key]['neighbor_port']\n       Replacements['SPINE4_IP'] = spines[key]['ip_address']\n       Replacements['SPINE4_NEIGHBOR_IP'] = '10.%s.%s.%s' % (key[-2:], leafIP / 256, leafIP % 256 - 1)\n       spine_counter = spine_counter + 1\n       \n \n  # Set all other variables in the replacement dict\n  Replacements['MTU'] = MTU\n  Replacements['SNMP_CONTACT'] = snmpContact\n  Replacements['SNMP_LOCATION'] = snmpLocation\n  Replacements['HOSTNAME'] = hostName\n  Replacements['MLAG_NAME'] = mlagName\n  Replacements['LOOPBACK1_IP'] = lo1\n  Replacements['MA_VRF'] = ma_vrf\n  Replacements['MA_IP'] = MA_IP\n  Replacements['MA_MASK'] = MA_MASK\n  Replacements['LOOPBACK900_IP'] = lo900\n  Replacements['LOOPBACK2_IP'] = lo2\n  Replacements['BGP_AS'] = BGP_AS\n  Replacements['MLAG_NEIGHBOR_IP'] = MLAG_NEIGHBOR_IP\n  Replacements['SPINE_AS'] = SPINE_AS\n  Replacements['EVPN_RTMAX'] = EVPN_RTMAX\n  Replacements['IBGP_RTMAX'] = IBGP_RTMAX\n  Replacements['EBGP_RTMAX'] = EBGP_RTMAX\n  Replacements['SPEED'] = 'speed forced %s' % speed\n\n\n\n \n  \n  # =======================================================\n  # Writing the configs as templates into CVP\n  # =======================================================\n  \n  print '! === autoconf report ==='\n  \n  # ================================================================\n  # Assign the existing model-specific configlet (like '7160-32CQ')\n  # ================================================================\n  configlet_name = 'sw-%s-%s-%s' % (LOCATION, leafType, leafModel)\n  \n  try:\n    cfg = server.cvpService.getConfigletByName (configlet_name)\n    server.cvpService.applyConfigletToDevice(dev.ipAddress, dev.fqdn, mac, [configlet_name], [cfg['key']], [], [])\n    print ('! Configlet %s assigned' % configlet_name)\n  except Exception as err:\n    print '! ERROR: Required configlet %s does not exist! (%s)' % (configlet_name, err)\n    return\n  # =======================================================\n  \n  \n  # =======================================================\n  # Assign the existing mlag configlet\n  # =======================================================\n  configlet_name = 'sw-mlag-%s' % leafLtr\n  \n  try:\n    cfg = server.cvpService.getConfigletByName (configlet_name)\n    server.cvpService.applyConfigletToDevice(dev.ipAddress, dev.fqdn, mac, [configlet_name], [cfg['key']], [], [])\n    print ('! Configlet %s assigned' % configlet_name)\n  except Exception as err:\n    print '! ERROR: Required configlet %s does not exist! (%s)' % (configlet_name, err)\n    return\n  # =======================================================\n\n\n  # =======================================================\n  # Prepare switch pair configlet\n  # =======================================================\n  configlet_name = '%s' % mlagName\n  \n  # Read Leaf pair Template (= extisting configlet) and replace all vars  \n  try:\n    template_leaf = server.cvpService.getConfigletByName(LEAF_PAIR_TEMPLATE)\n  except Exception as err:\n    print '! ERROR: Required template configlet %s does not exist! (%s)' % (LEAF_PAIR_TEMPLATE, err)\n    return\n  \n  try:\n    leaf_cfg = template_leaf['config']\n    pair_base_config = Template(leaf_cfg).substitute(Replacements)\n  except Exception as err:\n    print '! ERROR: Could not replace the placeholders in the template configlet %s! (%s)' % (LEAF_PAIR_TEMPLATE, err)\n    return\n  \n  try:\n    cfg = server.cvpService.getConfigletByName (configlet_name)\n    print ('! Configlet %s already exists, using it' % configlet_name)\n  except cvp.cvpServices.CvpError as err:\n    if (err.errorCode == errorCodes.ENTITY_DOES_NOT_EXIST):\n      try:\n        server.cvpService.addConfiglet (configlet_name, pair_base_config)\n        cfg = server.cvpService.getConfigletByName (configlet_name)\n        print '! Configlet %s created and assigned' % configlet_name\n      except Exception as err:\n        print '! ERROR: Not able to add configlet %s! (%s)' % (configlet_name, err)\n        return\n    else:\n      print '! ERROR: Communication issues with configlet %s! (%s)' % (configlet_name, err)\n      return\n    \n  try:\n    server.cvpService.applyConfigletToDevice(dev.ipAddress, dev.fqdn, mac, [configlet_name], [cfg['key']], [], [])\n    print ('! Configlet %s assigned' % configlet_name)\n  except Exception as err:\n    print '! ERROR: Not able to assign configlet %s! (%s)' % (configlet_name, err)\n    return\n  \n  # =======================================================\n  \n  \n  # =======================================================\n  # Prepare switch individual configlet\n  # =======================================================\n  configlet_name = '%s' % hostName\n  \n  # Read Leaf Template (= extisting configlet) and replace all vars  \n  try:\n    template_leaf = server.cvpService.getConfigletByName(LEAF_BASE_TEMPLATE)\n  except Exception as err:\n    print '! ERROR: Required template configlet %s does not exist! (%s)' % (LEAF_BASE_TEMPLATE, err)\n    return\n  \n  try:\n    leaf_cfg = template_leaf['config']\n    leaf_base_config = Template(leaf_cfg).substitute(Replacements)\n  except Exception as err:\n    print '! ERROR: Could not replace the placeholders in the template configlet %s! (%s)' % (LEAF_BASE_TEMPLATE, err)\n    return\n  \n  try:\n    cfg = server.cvpService.getConfigletByName (configlet_name)\n    print ('! Configlet %s already exists. Delete/rename to re-create!' % configlet_name)\n  except cvp.cvpServices.CvpError as err:\n    if (err.errorCode == errorCodes.ENTITY_DOES_NOT_EXIST):\n      try:\n        server.cvpService.addConfiglet (configlet_name, leaf_base_config)\n        cfg = server.cvpService.getConfigletByName (configlet_name)\n        server.cvpService.applyConfigletToDevice (dev.ipAddress, dev.fqdn, mac, [configlet_name], [cfg['key']], [], [])\n        print '! Configlet %s created and assigned' % configlet_name\n      except Exception as err:\n        print '! ERROR: Not able to add configlet %s! (%s)' % (configlet_name, err)\n        return\n    else:\n      print '! ERROR: Communication issues with configlet %s! (%s)' % (configlet_name, err)\n      return\n  \n  # =======================================================\n  \n  # =======================================================\n  # Create and assign the pair an empty CFM configlet for hana cells \n  # =======================================================\n  \n  if leafType == 'hana':\n    configlet_name = '%s.cfm' % mlagName\n  \n    try:\n\t    cfg = server.cvpService.getConfigletByName (configlet_name)\n\t    print ('! Configlet %s already exists, using it' % configlet_name)\n    except cvp.cvpServices.CvpError as err:\n\t    if (err.errorCode == errorCodes.ENTITY_DOES_NOT_EXIST):\n\t      try:\n\t        server.cvpService.addConfiglet(configlet_name, '')\n\t        cfg = server.cvpService.getConfigletByName (configlet_name)\n\t        print ('! Configlet %s created' % configlet_name)\n\t      except Exception as err:\n\t        print '! ERROR: Not able to add configlet %s! (%s)' % (configlet_name, err)\n\t        return\n\t    else:\n\t      print '! ERROR: Communication issues with configlet %s! (%s)' % (configlet_name, err)\n\t      return\n  \n    try:\n\t    server.cvpService.applyConfigletToDevice(dev.ipAddress, dev.fqdn, mac, [configlet_name], [cfg['key']], [], [])\n\t    print ('! Configlet %s assigned' % configlet_name)\n    except Exception as err:\n\t    print '! ERROR: Not able to assign configlet %s! (%s)' % (configlet_name, err)\n\t    return\n\t  \n  # =======================================================\n\n  # =======================================================\n  # Assign the 7160 switche the 7160-profile-tcam-acl configlet\n  # =======================================================\n  \n  if '7160' in leafModel:\n    configlet_name = PROFILE_TCAM_ACL\n  \n    try:\n      cfg = server.cvpService.getConfigletByName (configlet_name)\n      server.cvpService.applyConfigletToDevice(dev.ipAddress, dev.fqdn, mac, [configlet_name], [cfg['key']], [], [])\n      print ('! Configlet %s assigned' % configlet_name)\n    except Exception as err:\n      print \"! ERROR: Required configlet %s does not exist! (%s)\" % (configlet_name, err)\n      return\n  \n  # =======================================================\n  \n  print '! =======================\\n'\n  print '! ========= Individual config part ==============\\n'\n  print leaf_base_config\n  print '! =======================\\n'\n\n\n\nmain()\n","key":null}}}
