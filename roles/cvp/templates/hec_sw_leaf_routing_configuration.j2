{# hec_sw_leaf_routing_configuration.j2 #}
{% set asn_generated_global = [] %}
{#
 first, let's find out the leaf's purpose.
  - 'b' is a borderleaf
  - 's' is a storageleaf
  - 'h' is a hana shared storage-leaf
#}
{% set id_short = id | regex_replace('^.*(?P<id>[123456789][ab])$', '\\g<id>') %}
{% set leafpurpose = id | regex_replace('^(?P<purpose>[bsh])[123456789][ab]$', '\\g<purpose>') %}
{% set leafid = funcs.leafid(id) %}
{% set brdrtype = id | regex_replace('^.*(?P<one_or_two>[123456789])[ab]$', '\\g<one_or_two>') %}
{#
 based on the purpose, we set the list to loop through.
 this list is what we define under hec.* in hecXX.yml.

 say we have been called for a borderleaf, the leaf purpose will make us
 to set the loop_items to hec.brdr and we will then process each entry
 under hec.brdr
#}
{% set loop_items = hec.brdr %}
{% if leafpurpose == 's' %}
{% set loop_items = hec.str %}
{% endif %}
{% if leafpurpose == 'h' %}
{% set loop_items = hec.shs %}
{% endif %}
{#
 what we do next is to check for the "sub type" of the give leaf purpose.
 this just means we will not generate for each and every borderleaf listed under
 hec.brdr (f.e.) but we will only process brdr02a/b if "id_short" is set to "2".
#}
{% for allbrdrs in loop_items if allbrdrs.number == id_short %}
{% set spine_port_towards_leaf = allbrdrs.spine_port_towards_leaf %}
{% set cell_id = funcs.cell_id(spine_port_towards_leaf, leafid)|int %}
{% set asn_spine_part = 10000 %}
{% set asn_part = cell_id|int %}
{% if allbrdrs.pod is not defined %}{# START if switch is not assigned to a POD #}
{% set asn_part = asn_part + 10000 %}
{% else %}
{% set asn_part = asn_part + (10000 * allbrdrs.pod|int) %}
{% set asn_spine_part = asn_spine_part * allbrdrs.pod|int %}
{% endif %}{# END if switch is assigned to a POD #}
{% set asn_generated = '641' + hec.hec_nr + '.' + asn_part|string %}{# this is the ASN for a leaf #}
{% set _ = asn_generated_global.append(asn_generated) %}
{# !{{ asn_generated_global[0] }} #}
{% set asn_spine = '641' + hec.hec_nr + '.' + asn_spine_part|string %}{# this is the ASN for a spine #}
{% set intf_loopback1 = funcs.leaf_routerid(spine_port_towards_leaf, leafid, allbrdrs.pod|default(1)) %}
{% set intf_loopback2 = funcs.leaf_vtepid(spine_port_towards_leaf, leafid, allbrdrs.pod|default(1)) %}
interface Loopback1
   description Router-ID
   ip address {{ intf_loopback1 }}
!
interface Loopback2
   ip address {{ intf_loopback2 }}
!
{% set uplink_ipv4 = funcs.uplink_port_ip(item.spine_port_towards_leaf) %}
{% set nextsubnet = uplink_ipv4.split('.')[0] %}
{% set link_ip = uplink_ipv4.split('.')[1] %}
{% for intf in allbrdrs.uplinks %}
{% set spine_pod_offset = 10 * allbrdrs.pod|default(1) %}
interface Ethernet{{ intf }}
   ip address 10.{{ loop.index + spine_pod_offset }}.{{ nextsubnet }}.{{ link_ip }}/31
!
{% endfor %}
ip routing
no ip routing vrf OOB
!
{% if (hec.spine.underlay_bfd) and (leafpurpose == 'b') %}
{% for entry in ['198.19.249.0/24', '198.19.251.0/24', '10.254.200.0/24'] %}
ip prefix-list PL-EDGE seq {{ loop.index * 10 }} permit {{ entry }} eq 32
{% endfor %}
!
route-map RM-EDGE permit 10
   match ip address prefix-list PL-EDGE
!
route-map RM-EDGE deny 20
{% endif %}
!
router bgp {{ asn_generated }}
   bgp asn notation asdot
   router-id {{ intf_loopback1.split('/')[0] }}
   maximum-paths 8 ecmp 16
   !
{% for setting in [eos_cmd.c_neighbor_peer_group, 'remote-as ' + asn_spine, 'route-map MLPEER-RM out',
                'send-community', 'maximum-routes ' + hec.fabric.bgp_maximum_routes|string, eos_cmd.c_neighbor_soft_reconfiguration + ' all'] %}
   neighbor SPINE-PG {{ setting }}
{% endfor %}
{% if hec.spine.underlay_bfd %}
   neighbor SPINE-PG {{eos_cmd.c_neighbor_fall_over_bfd}}
{% endif %}
   !
{% for setting in [eos_cmd.c_neighbor_peer_group, 'remote-as ' + asn_generated, 'next-hop-self',
               'maximum-routes ' + hec.fabric.bgp_maximum_routes|string] %}
   neighbor MLPEER-PG {{ setting }}
{% endfor %}
   !
{% if (hec.ngdr_underlay is defined) and (leafpurpose == 'b') %}
{% for setting in [eos_cmd.c_neighbor_peer_group, 'remote-as ' + hec.ngdr_underlay.edge_as|string, 'route-map RM-EDGE in', 'route-map RM-EDGE out',
               'maximum-routes ' + hec.fabric.bgp_maximum_routes|string, 'send-community', eos_cmd.c_neighbor_fall_over_bfd, eos_cmd.c_neighbor_soft_reconfiguration + ' all'] %}
   neighbor EDGE-PG {{ setting }}
{% endfor %}
{% for edge_neighbor in allbrdrs.ports %}
{% if (edge_neighbor.type is defined) and (edge_neighbor.type == "vlan") and (edge_neighbor.ngdr_underlay is defined) and (edge_neighbor.ngdr_underlay)%}
   neighbor {{ edge_neighbor.ngdr_underlay_neighbor }} {{eos_cmd.c_neighbor_peer_group}} EDGE-PG
   neighbor {{ edge_neighbor.ngdr_underlay_neighbor }} update-source Vlan{{ edge_neighbor.id }}
{% endif %}
{% endfor %}
   !
{% endif %}
   !
{% for i in range(1,5) %}
{% if allbrdrs.pod is not defined %}
   neighbor 10.{{ loop.index + 10 }}.{{ nextsubnet }}.{{ link_ip|int - 1 }} {{eos_cmd.c_neighbor_peer_group}} SPINE-PG
{% else %}
{% if allbrdrs.pod == 1 %}
   neighbor 10.{{ loop.index + 10 }}.{{ nextsubnet }}.{{ link_ip|int - 1 }} {{eos_cmd.c_neighbor_peer_group}} SPINE-PG
{% else %}
   neighbor 10.{{ loop.index + 10 + (10 * (allbrdrs.pod - 1)) }}.{{ nextsubnet }}.{{ link_ip|int - 1 }} {{eos_cmd.c_neighbor_peer_group}} SPINE-PG
{% endif %}
{% endif %}
{% endfor %}
{% set mlag_ip_peer  = hec.fabric.mlag_a_ip %}
{% if leafid == 'a' %}
{% set mlag_ip_peer  = hec.fabric.mlag_b_ip %}
{% endif %}
   neighbor {{ mlag_ip_peer }} {{eos_cmd.c_neighbor_peer_group}} MLPEER-PG
   !
{% for network in [ intf_loopback1, intf_loopback2, allbrdrs.nwmgmt_ip + '/32'] %}
   network {{ network }}
{% endfor %}
{% if (brdrtype == '2') and (leafpurpose == 'b') %}
   network {{ hec.inband_trans_net }}
{% endif %}
   !
{% if hec.fabric.vtep_distribution_mode == "evpn" or hec.fabric.vtep_distribution_mode== "migrate" %}
{% for setting in [eos_cmd.c_neighbor_peer_group, 'remote-as ' + asn_spine, 'update-source Loopback1', 'ebgp-multihop 2',
               'maximum-routes ' + hec.fabric.evpn_maximum_routes|string, 'send-community standard extended', eos_cmd.c_neighbor_fall_over_bfd] %}
   neighbor EVPN-PG {{ setting }}
{% endfor %}
   !
{% for i in range(11,15) %}
{% if allbrdrs.pod is not defined %}
   neighbor 10.100.0.{{i}} {{eos_cmd.c_neighbor_peer_group}} EVPN-PG
{% else %}
{% if allbrdrs.pod == 1 %}
   neighbor 10.100.0.{{i}} {{eos_cmd.c_neighbor_peer_group}} EVPN-PG
{% else %}
   neighbor 10.1{{ allbrdrs.pod - 1 }}0.{{ hec.hec_nr|int }}.{{ i + (10 * (allbrdrs.pod - 1))}} {{eos_cmd.c_neighbor_peer_group}} EVPN-PG
{% endif %}
{% endif %}
{% endfor %}
   !
   address-family evpn
      neighbor EVPN-PG activate
   !
   address-family ipv4
      no neighbor EVPN-PG activate
   !
   address-family ipv6
      no neighbor EVPN-PG activate
   !
{% if hec.fabric.vtep_distribution_mode != "migrate" %}
   vlan-aware-bundle all-vlans
      rd 10.{{ 200 + (cell_id/100)|int }}.{{ allbrdrs.pod|default(1) }}.{{ cell_id % 100 }}:1
      route-target both 1:1
      redistribute learned
{% set ns = namespace(vlans_right_side_end=0) %}
{% for item in vlans.ranges -%}
  {% if item.name == 'cust_backend' %}
    {% set ns.vlans_right_side_end = item.range.split('-') %}
    {% set _ = ns.vlans_right_side_end[1] %}
  {% endif %}
{%- endfor %}
! # awesome new code (testing only). result is: {{ns.vlans_right_side_end}}
{% if leafpurpose != 'b' %}
      vlan 5-{{ns.vlans_right_side_end[1]}}
{% else %}
{% if (brdrtype == '1') or (brdrtype == '3') or (brdrtype == '4') or (brdrtype == '5') %}
{% if (hec.core_vlans is defined) and (hec.core_vlans == true) %}
      vlan 5-3499
{% else %}
      vlan 5-2499
{% endif %}
{% elif (brdrtype == '2')  %}
      vlan 5-2499
{% endif %}
{% endif %}
      exit
{% endif %}
   exit
!
{% endif %}{# END vtep_distribution_mode evpn? #}
{#
  if this a storage switch, we do not need vni mappings for vlan 30 & 920
#}
{% if leafpurpose == 's' %} {# START storageleaf - remove vni for vlan 30 & 920 #}
interface Vxlan1
{% for i in (30,920) %}
   no vxlan vlan {{i}} vni {{i+10000}}
{% endfor %}
{% endif %}{# END storageleaf - remove vni for vlan 30 & 920 #}
{% if leafpurpose == 'b' %}
{% if (brdrtype == '1') or (brdrtype == '3') or (brdrtype == '4') or (brdrtype == '5') %}
{#
  we need to have vlans and the vni mapping for 3000-3499
  if the core routers and wan/vpn routers are still doing
  static transfer networks for wan/vpn connections
#}
{% if hec.core_vlans|default('', true) %}
vlan {% for item_range in vlans.ranges %}{% if item_range.name == 'cust_static_trans' %}{{item_range.range}}{% endif %}{% endfor %}

!
interface Vxlan1
{% for i in range(0,500) %}
   vxlan vlan {{ i + 3000 }} vni {{ i + 3000 }}000
{% endfor %}
{% endif %}{# END hec.core_vlans? #}
{% endif %}{# END brdrtype 1/3 ? #}
{% endif %}{# END leafpurpose=='b' #}
!
{% endfor %}
{#
  Let's see if there are any (static) routes to be configured.
  Depending on the type of leaf we will check for existance of the
  dictionary "hec.routes.static.$LEAFTYPE".
#}
{#
  Create empty list first. Only for non-empty route_dictionary
  the macro will be called.
#}
{% set route_dictionary = [] %}
{#
  We need to determine what list to iterate through, so let's find out
  what type of "specical leaf" we are currently working with.
#}
{% if hec.routes.static is defined %}
{% for item_rt_static in hec.routes.static %}
{# ! {{item_rt_static}}
! {{hec.routes.static[item_rt_static]}} #}
{# get the type number (tailing integer like 1,2,3,...) #}
{% set num_tailing = item_rt_static | regex_replace('^.*(?P<num_tailing>[123456789])$', '\\g<num_tailing>') %}
{#
  loop through all subitems. depending on the actual switch purpose we are working at,
  we do loop through all the subitems.
#}
{% if leafpurpose == 'b' and item_rt_static is search("brdr") %}
{% if brdrtype == num_tailing %}
{% set _ = route_dictionary.append(hec.routes.static[item_rt_static]) %}
{# ! inner for-loop var "route_dictionary": {{route_dictionary}}
! new static route code. it should have set the route_dictionary with hec.routes.static.brdr* dictionary
! {{route_dictionary}} #}
{% endif %}
{% endif %}
{% if leafpurpose == 's' and item_rt_static is search("str") %}
{% if brdrtype == num_tailing %}
{% set _ = route_dictionary.append(hec.routes.static[item_rt_static]) %}
{% endif %}
{% endif %}
{% if leafpurpose == 'h' and item_rt_static is search("shs") %}
{% if brdrtype == num_tailing %}
{% set _ = route_dictionary.append(hec.routes.static[item_rt_static]) %}
{% endif %}
{% endif %}
{% endfor %}
{% endif %}{# endif hec.routes.statis is defined #}
{#
  The keys 'nexthop', 'interface', 'metric', 'vrf'
  are optional, so if they have not been set, we set it
  to emtpy strings befor calling the macro
#}
{% if route_dictionary[0] is defined %}
{% for route in route_dictionary[0] %}
{% if route.vrf is not defined %}
{% set vrf = '' %}
{% else %}
{% set vrf = route.vrf %}
{% endif %}
{% if route.interface is not defined %}
{% set interface = '' %}
{% else %}
{% set interface = route.interface %}
{% endif %}
{% if route.nexthop is not defined %}
{% set nexthop = '' %}
{% else %}
{% set nexthop = route.nexthop %}
{% endif %}
{% if route.metric is not defined %}
{% set metric = '' %}
{% else %}
{% set metric = route.metric|string %}
{% endif %}
{% if route.redist_bgp is not defined %}
{% set redist_bgp = False %}
{% else %}
{% set redist_bgp = route.redist_bgp %}
{% endif %}
{#
  call the macro to render the route statement
#}
{{ funcs.render_route_statement(route.destination, nexthop, vrf, interface, metric, redist_bgp, asn=asn_generated_global[0]) }}
{% endfor %}
{% endif %}
